{
  "UnionFind": {
    "prefix": "UnionFind",
    "body": [
      "struct UnionFind {",
      "    parents: Vec<usize>,",
      "    ranks: Vec<usize>,",
      "}",
      "impl UnionFind {",
      "    fn new(len: usize) -> UnionFind {",
      "        return UnionFind {",
      "            parents: (0..len).map(|i| i).collect(),",
      "            ranks: vec![0; len],",
      "        };",
      "    }",
      "    fn root(&mut self, x: usize) -> usize {",
      "        if self.parents[x] == x {",
      "            x",
      "        } else {",
      "            let root_of_parent = self.root(self.parents[x]);",
      "            self.parents[x] = root_of_parent;",
      "            root_of_parent",
      "        }",
      "    }",
      "    fn same(&mut self, x: usize, y: usize) -> bool {",
      "        return self.root(x) == self.root(y);",
      "    }",
      "    fn union(&mut self, x: usize, y: usize) {",
      "        let root_x = self.root(x);",
      "        let root_y = self.root(y);",
      "        if root_x == root_y {",
      "            return;",
      "        }",
      "        if self.ranks[root_x] < self.ranks[root_y] {",
      "            self.parents[root_x] = root_y;",
      "        } else {",
      "            self.parents[root_y] = root_x;",
      "            if self.ranks[root_x] == self.ranks[root_y] {",
      "                self.ranks[root_x] += 1;",
      "            }",
      "        }",
      "    }",
      "}"
    ]
  },
  "UnionFind-struct": {
    "prefix": "UnionFind-struct",
    "body": [
      "struct UnionFind {",
      "    parents: Vec<usize>,",
      "    ranks: Vec<usize>,",
      "}"
    ]
  },
  "Vec<char> to string": {
    "prefix": "Vec<char> to string",
    "body": [
      "fn vec_char_to_string(vec: &Vec<char>) -> String {",
      "    vec.into_iter().collect()",
      "}"
    ]
  },
  "_factorial": {
    "prefix": "_factorial",
    "body": [
      "fn _factorial(n: usize, memo: &mut Vec<usize>) -> usize {",
      "    if n < 2 || memo[n] > 1 {",
      "        memo[n]",
      "    } else {",
      "        memo[n] = _factorial(n - 1, memo) * n;",
      "        memo[n]",
      "    }",
      "}"
    ]
  },
  "a-z": {
    "prefix": "a-z",
    "body": [
      "fn a_z_vec_char() -> Vec<char> {",
      "    (b'a'..=b'z').map(|b| b as char).collect()",
      "}"
    ]
  },
  "char_to_u32": {
    "prefix": "char_to_u32",
    "body": [
      "fn char_to_u32(c: Vec<char>) -> u32 {",
      "    let a = c[0].to_digit(10).unwrap();",
      "    let b = c[1].to_digit(10).unwrap();",
      "    a * b",
      "}"
    ]
  },
  "create_vec_by_range": {
    "prefix": "create_vec_by_range",
    "body": [
      "fn create_vec_by_rane(start: usize, end: usize) -> Vec<usize> {",
      "    (start..end).collect()",
      "}"
    ]
  },
  "digit sum": {
    "prefix": "digit sum",
    "body": [
      "fn digit_sum(s: &String) -> u32 {",
      "    s.chars().map(|c| c.to_digit(10).unwrap()).sum()",
      "}"
    ]
  },
  "exec_time": {
    "prefix": "exec_time",
    "body": [
      "use std::time::Instant;"
    ]
  },
  "factorial - 階乗": {
    "prefix": "factorial - 階乗",
    "body": [
      "fn _factorial(n: usize, memo: &mut Vec<usize>) -> usize {",
      "    if n < 2 || memo[n] > 1 {",
      "        memo[n]",
      "    } else {",
      "        memo[n] = _factorial(n - 1, memo) * n;",
      "        memo[n]",
      "    }",
      "}",
      "fn factorial(n: usize) -> usize {",
      "    let mut memo: Vec<usize> = vec![1; n + 1];",
      "    _factorial(n, &mut memo)",
      "}"
    ]
  },
  "find_index": {
    "prefix": "find_index",
    "body": [
      "fn find_index<T: PartialEq + Copy>(vec: &Vec<T>, search_target: T) -> usize {",
      "    vec.iter().position(|&x| x == search_target).unwrap()",
      "}"
    ]
  },
  "get_input-標準入力を1行読み込む": {
    "prefix": "get_input-標準入力を1行読み込む",
    "body": [
      "fn get_input<T: FromStr>() -> Vec<T> {",
      "    let mut buffer = String::new();",
      "    io::stdin().read_line(&mut buffer).ok();",
      "    buffer",
      "        .trim()",
      "        .split_whitespace()",
      "        .map(|x| x.parse().ok().unwrap())",
      "        .collect()",
      "}"
    ]
  },
  "get_input-標準入力を複数行読み込む": {
    "prefix": "get_input-標準入力を複数行読み込む",
    "body": [
      "fn get_input<T: FromStr>() -> Vec<T> {",
      "    let mut buffer = String::new();",
      "    io::stdin().read_line(&mut buffer).ok();",
      "    buffer",
      "        .trim()",
      "        .split_whitespace()",
      "        .map(|x| x.parse().ok().unwrap())",
      "        .collect()",
      "}",
      "fn get_input_lines<T: FromStr>(line_len: usize) -> Vec<Vec<T>> {",
      "    let mut vec: Vec<Vec<T>> = vec![];",
      "    for _ in 0..line_len {",
      "        let v: Vec<T> = get_input();",
      "        vec.push(v);",
      "    }",
      "    vec",
      "}"
    ]
  },
  "interleave": {
    "prefix": "interleave",
    "body": [
      "fn interleave_vec_char(a: Vec<char>, b: Vec<char>) -> Vec<char> {",
      "    a.into_iter().interleave(b).collect()",
      "}"
    ]
  },
  "lower_bound - 二分探索": {
    "prefix": "lower_bound - 二分探索",
    "body": [
      "fn lower_bound(v: &Vec<usize>, s: usize) -> usize {",
      "    let mut left = 0;",
      "    let mut right = v.len();",
      "    while left != right {",
      "        let mid = (left + right) / 2;",
      "        if s > v[mid] {",
      "            left = mid + 1;",
      "        } else {",
      "            right = mid;",
      "        }",
      "    }",
      "    left",
      "}"
    ]
  },
  "permutations-順列全列挙": {
    "prefix": "permutations-順列全列挙",
    "body": [
      "fn permutaions(start: usize, end: usize, num: usize) -> Vec<Vec<usize>> {",
      "    (start..end).permutations(num).collect()",
      "}"
    ]
  },
  "sort chars of String": {
    "prefix": "sort chars of String",
    "body": [
      "fn sort_chars_of_string(s: &String) -> Vec<char> {",
      "    s.chars().sorted().collect_vec()",
      "}"
    ]
  },
  "string_to_vec_u32": {
    "prefix": "string_to_vec_u32",
    "body": [
      "fn string_to_vec_u32(s: &String) -> Vec<u32> {",
      "    s.chars().map(|c| c.to_digit(10).unwrap()).collect()",
      "}"
    ]
  },
  "sum": {
    "prefix": "sum",
    "body": [
      "fn sum(vec: Vec<u32>) -> u32 {",
      "    vec.iter().sum()",
      "}"
    ]
  },
  "swap": {
    "prefix": "swap",
    "body": [
      "fn swap_char(a: &String, b: &String, idx: usize) -> (String, String) {",
      "    let mut av: Vec<char> = a.chars().collect();",
      "    let mut bv: Vec<char> = b.chars().collect();",
      "    std::mem::swap(&mut av[idx], &mut bv[idx]);",
      "    let new_a: String = av.into_iter().collect();",
      "    let new_b: String = bv.into_iter().collect();",
      "    (new_a, new_b)",
      "}"
    ]
  },
  "typename": {
    "prefix": "typename",
    "body": [
      "fn typename<T>(_: T) -> &'static str {",
      "    std::any::type_name::<T>()",
      "}"
    ]
  },
  "unique_chars": {
    "prefix": "unique_chars",
    "body": [
      "fn string_to_hashset_char(s: &String) -> HashSet<char> {",
      "    let vec: Vec<char> = s.clone().chars().collect();",
      "    vec.into_iter().collect()",
      "}"
    ]
  },
  "unique_strings": {
    "prefix": "unique_strings",
    "body": [
      "fn vec_string_to_hashset(words: &Vec<String>) -> HashSet<String> {",
      "    words.clone().into_iter().collect()",
      "}"
    ]
  },
  "upper_bound - 二分探索": {
    "prefix": "upper_bound - 二分探索",
    "body": [
      "fn upper_bound(v: &Vec<usize>, s: usize) -> usize {",
      "    let mut left = 0;",
      "    let mut right = v.len();",
      "    while left != right {",
      "        let mid = (left + right) / 2;",
      "        if s < v[mid] {",
      "            right = mid;",
      "        } else {",
      "            left = mid + 1;",
      "        }",
      "    }",
      "    left",
      "}"
    ]
  },
  "進数変換": {
    "prefix": "進数変換",
    "body": [
      "fn convert_digits(num: i64, digit: usize) -> String {",
      "    match digit {",
      "        2 => format!(\"{:b}\", num),",
      "        8 => format!(\"{:o}\", num),",
      "        10 => format!(\"{}\", num),",
      "        16 => format!(\"{:x}\", num),",
      "        _ => format!(\"{}\", num),",
      "    }",
      "}"
    ]
  }
}
